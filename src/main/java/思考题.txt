思考题
1：A线程正在执行一个对象中的同步方法，B线程是否可以同时执行同一个对象中的非同步方法？
   可以

2：同上，B线程是否可以同时执行同一个对象中的另一个同步方法？
   不可以

3：线程抛出异常会释放锁吗？
   会

4：volatile和synchronized区别？
   volatile关键字保证线程间的共享变量的可见性，并且会禁止指令重排序
   synchronized关键字是一把隐式锁，不需要手工的加解锁，前期比较重后面的版本经过优化之后性能也比较好了，可重入、非公平、底层实现是JVM来实现的，通过底层的硬件执行来控制
               加锁的方式有三种，1：同步实例方法，锁是当前实例对象；2：同步类方法，锁是当前类对象；3：同步代码块，锁是指定的对象，放入小括号内的对象

5：写一个程序，证明AtomXXX类比synchronized更高效

6：AtomXXX类可以保证可见性吗？请写一个程序来证明
   可以，

7：写一个程序证明AtomXXX类的多个方法并不构成原子性
   多个原子性的操作组合在一起，可能就不是原子性的了，因为原子性的操作之间可能存在阻塞或者异常

8：写一个程序模拟死锁
   思路：两个线程A和B，两把锁L1和L2，线程A先获取L1，休眠1秒钟，然后获取L2，线程B先获取L2，休眠1秒钟，然后获取L1
        或者多个线程多把锁，循环的获取

9：写一个程序，在main线程中启动100个线程，100个线程完成后，主线程打印“完成”，使用join()和countdownlatch都可以完成，请比较异同。
   结论：countDownLatch的性能会更好一些

10：一个高效的游戏服务器应该如何设计架构？



其他关于JUC的代码

https://github.com/topics/juc

https://github.com/MaJesTySA/JVM-JUC-Core